
local function find_name(name, children)
	for _, node in pairs(children) do
		if node.name == name then
			return true
		end
	end
	return false
end

local function L(name, children)
	children = children or {}
	table.insert(children, 1, N("config"))
	table.insert(children, 2, N("types"))
	return N(name, children)
end

T = L

function M(name, children)
	children = children or {}
	table.insert(children, 1, N("types"))
	if not find_name(name, children) then
		table.insert(children, 2, N(name))
	end
	return N(name, children)
end

function I(name, children)
	children = children or {}
	table.insert(children, 1, N("types"))
	table.insert(children, 2, N("private"))
	return N(name, children)
end

function library(name)
	local children = dofile(string.format("lib/%s/include_order", name))
	return L(name, children)
end

config.print_ok = false
config.paths = {}

local libs = {
	"core",
	"game",
}

local lib_nodes = {}
for _, name in pairs(libs) do
	table.insert(lib_nodes, library(name))
	table.insert(config.paths, string.format("lib/%s/src", name))
end

config.order_tree = make_order_tree(
-- extension order
{"hpp", "ipp", "gen_interface"},
-- order nodes
{
	N("togo", lib_nodes),
},
-- explicit path values
{})

config.exclusions = make_inverse_table({
	"togo/external/dlmalloc.hpp"
})
config.extension_filter = make_inverse_table({
	"hpp", "ipp", "cpp", "cxx", "gen_interface"
})

config.override_path_value = function(_, path, extension, computed_value)
	if
		string.match(path, "^togo/%w+/config$") or
		string.match(path, "^togo/%w+/tool_%w+/config$")
	then
		return 0
	elseif
		string.match(path, "^togo/%w+/types$") or
		string.match(path, "^togo/%w+/tool_%w+/types$")
	then
		return 1
	elseif extension == "gen_interface" then
		-- Force to the bottom of the include block
		return -1
	end
	return computed_value
end
